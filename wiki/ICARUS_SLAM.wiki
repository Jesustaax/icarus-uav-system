#summary One-sentence summary of this page.

[ICARUS_SLAM#Operation Operating Instructions]
[https://bitbucket.org/davidgitz/icarus_slam Source Code]

[PrimaryController Primary Controller]
[FlightController Flight Controller]

= Introduction =

== Summary ==
This project is to implement a mapping system onboard a flying UAV (ICARUS Flyer).  The ICARUS Flyer employs a reputable and wide-supported autopilot system (The DIYDrones APM 2.0) with GPS based navigation.  For indoor environments GPS is rendered useless so a different approach is required.  However it is not appropriate to alter the source code on the APM as it is in a constant state of development.  So a solution is developed using a Kinect Sensor, RGBDSLAM and a Single-Board-Computer (SBC) that is able to produce a GPS-like coordinate system that is transferred to the APM, which then can conduct its very well developed navigation algorithms.

== Basic Operation ==

 # Primary Controller creates a map of an indoor environment using the Kinect Sensor and open-source SLAM algorithms (RGBDSLAM).
 # Primary Controller converts position estimate from SLAM algorithm to GPS-like coordinate system, using an initial GPS position.
 # Primary Controller transmits GPS-like coordinates to APM at 5-10Hz rate, using the NMEA 0183 protocol.
 # Primary Controller transmits information to GCS (QGroundControl) about current position using MAVLink
 # User using GCS creates Waypoints which are transmitted to Primary Controller.
 # Primary Controller transmits Waypoints and other required information to APM (including Arming information)
 # APM performs flight maneuvers to navigate between current position and target waypoints.

NOTE: In the future, the waypoints will be selected autonomously.  Look here for more information: [TargetDetection]

NOTE: In the future, the ICARUS Flyer will be able to transition between an outdoor environment with actual GPS data to an indoor (or other GPS-denied) environment with the GPS-like position data.

= Tasks =
 * Joystick (Not Started)
 * GPS Hacking, Checksum (INW)
 * MAVLink Commands (INW)
 * SLAM (Requires Testing)
 * MAVLink connection to Mission Planner/QGroundControl (QGC-INW,MP-Not Started)
 * Install Kinect on UAV (Not Started)
 * TCP Connection to Tablet running DroidPlanner (HOLD)


= Milestones =
 # Manual Flight of UAV (INW)
 # Position estimation (GPS) of UAV (No transmission to APM) (INW)
   * Require initial Heading information (Not Started)
 # Minimal comm links established with APM and GCS 
   * GPS 3D Fix on APM (INW)
   * Position update on GCS (DONE)
   * Waypoint commands to APM over MAVLink (Not Started)
 # APM autonomous navigation between waypoints using rolling cart testbed (Not Started)
 # Implementation on SBC (Not Started)
 # APM navigation between waypoints using actual flying maneuvers (Not Started)

= Details =

= Installation/Development Instructions =

= SLAM Stuff =
Original source code:
[http://www.ros.org/wiki/rgbdslam ROS-RGBDSLAM]

http://answers.ros.org/question/11755/rgbdslam-camera-location/

http://mediabox.grasp.upenn.edu/roswiki/doc/api/rgbdslam/html/annotated.html

http://answers.ros.org/question/11181/getting-position-and-orientation-from-rgbdslam/

http://answers.ros.org/question/33909/rgbdslam-octomap-for-continuous-realtime-mapping/

= MAVLink Stuff =
https://code.google.com/p/ardupilot-mega/wiki/MAVLink

http://qgroundcontrol.org/mavlink/start

https://pixhawk.ethz.ch/mavlink/

== Commands ==
The following are commands that may be required to transmit to/from the APM


Relevant Arducopter Code: GCS_Mavlink.pde

= GPS Stuff =
https://code.google.com/p/arducopter/wiki/GPSDisable

Emaluated GPS: Mediatek, 38400 baud

Default Position:

Latitude: 41.870404

Longitude: -87.649293

Latitude: 1 deg = 110.54 km

Longitude: 1 deg = 111.320*cos(latitude) km

== Required APM Messages ==
(From AP_GPS_NMEA.cpp)
{{{
case _GPS_SENTENCE_GPRMC:
                    time                        = _new_time;
                    date                        = _new_date;
                    latitude            = _new_latitude * 10;   // degrees*10e5 -> 10e7
                    longitude           = _new_longitude * 10;  // degrees*10e5 -> 10e7
                    ground_speed_cm     = _new_speed;
                    ground_course_cd    = _new_course;
                    fix                 = GPS::FIX_3D;          // To-Do: add support for proper reporting of 2D and 3D fix
                    break;
case _GPS_SENTENCE_GPGGA:
                    altitude_cm         = _new_altitude;
                    time                        = _new_time;
                    latitude            = _new_latitude * 10;   // degrees*10e5 -> 10e7
                    longitude           = _new_longitude * 10;  // degrees*10e5 -> 10e7
                    num_sats            = _new_satellite_count;
                    hdop                        = _new_hdop;
                    fix                 = GPS::FIX_3D;          // To-Do: add support for proper reporting of 2D and 3D fix
                    break;
case _GPS_SENTENCE_GPVTG:
                    ground_speed_cm     = _new_speed;
                    ground_course_cd    = _new_course;
                    // VTG has no fix indicator, can't change fix status
                    break;
}}}

== NMEA 0183 ==
Required GPS Packets for ArduCopter v3.0.1:
RMC,GGA,VTG

http://en.wikipedia.org/wiki/NMEA_0183

http://www.tronico.fi/OH6NT/docs/NMEA0183.pdf

=== RMC ===
RMC Recommended Minimum Navigation Information

$--RMC,hhmmss.ss,A,llll.ll,a,yyyyy.yy,a,x.x,x.x,xxxx,x.x,a*hh

 # Time (UTC)
 # Status, V = Navigation receiver warning
 # Latitude
 # N or S
 # Longitude
 # E or W
 # Speed over ground, knots
 # Track made good, degrees true
 # Date, ddmmyy
 # Magnetic Variation, degrees
 # E or W
 # Checksum

=== GGA ===
GGA Global Positioning System Fix Data. Time, Position and fix related data
for a GPS receiver

$--GGA,hhmmss.ss,llll.ll,a,yyyyy.yy,a,x,xx,x.x,x.x,M,x.x,M,x.x,xxxx*hh
 # Time (UTC)
 # Latitude
 # N or S (North or South)
 # Longitude
 # E or W (East or West)
 # GPS Quality Indicator: 0 - fix not available, 1 - GPS fix, 2 - Differential GPS fix
 # Number of satellites in view, 00 - 12
 # Horizontal Dilution of precision
 # Antenna Altitude above/below mean-sea-level (geoid)
 # Units of antenna altitude, meters
 # Geoidal separation, the difference between the WGS-84 earth ellipsoid and mean-sea-level (geoid), "-" means mean-sea-level below ellipsoid
 # Units of geoidal separation, meters
 # Age of differential GPS data, time in seconds since last SC104  type 1 or 9 update, null field when DGPS is not used
 # Differential reference station ID, 0000-1023
 # Checksum

=== VTG ===

VTG Track Made Good and Ground Speed

$--VTG,x.x,T,x.x,M,x.x,N,x.x,K*hh
 # Track Degrees
 # T = True
 # Track Degrees
 # M = Magnetic
 # Speed Knots
 # N = Knots
 # Speed Kilometers Per Hour
 # K = Kilometres Per Hour
 # Checksum

== Compiling ==
{{{
roscd slam_icarus
rosmake slam_icarus
}}}
On my Ubuntu Laptop it required 837.7 seconds to compile.

== Commit ==
 # Add any uncommitted files:
{{{
git add .
}}}
 # Make a comment on the commit and then push it to the main branch.
{{{
git commit -m "Comment Text"
git push -u origin master
}}}

= Operation =
== Headless ==
 * In Terminal 1:
{{{
roscore
}}}

 * In Terminal 2:
{{{
roslaunch rgbdslam slow_computer2.launch
}}}
 
 * In Terminal 3:
{{{
sudo chmod 0777 /dev/ttyACM0
rosservice call /rgbdslam/ros_ui_b pause false
}}}

Execute the main program with the following:
{{{
python nodes/primarycontroller.py
}}}
The following options are available.  Use the text in the <> where applicable, | signifies different options, and omit the <> and |:
 * Connection to GCS (Transmit GPS and Attitude Completed)
{{{
--gcs-device-type=<udp|Serial>
--gcs-device=<Device> #Where Device is an IP address if the type is udp, or a Serial Device such as /dev/ttyUSB0 or /dev/ttyACM0
--gcs-device-speed=<Speed> #Where Speed is a compatible baud rate if the type is Serial (default is 115200) and not used the type is udp 
}}}
 * Connection to Flight Controller (Receive Attitude Completed)
{{{
--fc-device-type=<udp|Serial>
--fc-device=<Device> #Where Device is an IP address if the type is udp, or a Serial Device such as /dev/ttyUSB0 or /dev/ttyACM0
--fc-device-speed=<Speed> #Where Speed is a compatible baud rate if the type is Serial (default is 115200) and not used the type is udp 
}}}
 * Connection to Flight Controller GPS (In Progress)
{{{
--fc_gps-device-type=<udp|Serial>
--fc_gps-device=<Device> #Where Device is an IP address if the type is udp, or a Serial Device such as /dev/ttyUSB0 or /dev/ttyACM0
--fc_gps-device-speed=<Speed> #Where Speed is a compatible baud rate if the type is Serial (default is 115200) and not used the type is udp 
}}}
 * Connection to Motion Controller (In Progress)
{{{
--mc-device-type=<udp|Serial>
--mc-device=<Device> #Where Device is an IP address if the type is udp, or a Serial Device such as /dev/ttyUSB0 or /dev/ttyACM0
--mc-device-speed=<Speed> #Where Speed is a compatible baud rate if the type is Serial (default is 115200) and not used the type is udp 
}}}
 * Connection to Remote (Transmit GPS and Attitude In Progress)
{{{
--remote-device-type=<udp|Serial>
--remote-device=<Device> #Where Device is an IP address if the type is udp, or a Serial Device such as /dev/ttyUSB0 or /dev/ttyACM0
--remote-device-speed=<Speed> #Where Speed is a compatible baud rate if the type is Serial (default is 115200) and not used the type is udp 
}}}

== GUI ==
 * In Terminal 1:
{{{
roscore
}}}

 * In Terminal 2:
{{{
rosrun rviz rviz
}}}

 * In Terminal 3:
{{{
roslaunch rgbdslam slow_computer2.launch
}}}
When GUI opens, press SPACE.
In RVIZ, Global Status should turn from ERROR to OK after moving.
 * In Terminal 4:
{{{
rosrun tf tf_echo /map /camera_link
}}}