#summary This page provides documentation on the software running on the ICARUS Flyer and/or supporting the design/analysis of the ICARUS Flyer.

= Introduction =

Provided here is documentation on the software running on the ICARUS Flyer as well as software that is directly used to support the design/analysis process on the ICARUS Flyer.


= Future Work =
== Aero Design ==
  * Center of Gravity/Center of Pitching Moment Axis Optimization
  * Front/Back Wing Area/Span Optimization

== Flyer Analysis ==
  * Improvements in Analysis software (MatLab APM Analyzer)
 
== Flyer Controls ==
  * Secondary Controller Software  

= Software = 
== Onboard ==

=== ArduPlane Relevant Code ===
_ArduPlane.pde_
{{{
// apply desired roll, pitch and yaw to the plane 
    // ----------------------------------------------
    if (control_mode > MANUAL)
        stabilize();

    // write out the servo PWM values
    // ------------------------------
    set_servos();

    gcs_update();
    gcs_data_stream_send();
}
}}}

_Attitude_
{{{

/*****************************************
* Set the flight control servos based on the current calculated values
*****************************************/
static void set_servos(void)
{
    int16_t flapSpeedSource = 0;
    int16_t last_throttle = g.channel_throttle.radio_out;

    if(control_mode == MANUAL) {
        // do a direct pass through of radio values
        if (g.mix_mode == 0) {
            g.channel_roll.radio_out                = g.channel_roll.radio_in;
            g.channel_pitch.radio_out               = g.channel_pitch.radio_in;
        } else {
            g.channel_roll.radio_out                = APM_RC.InputCh(CH_ROLL);
            g.channel_pitch.radio_out               = APM_RC.InputCh(CH_PITCH);
        }
        g.channel_throttle.radio_out    = g.channel_throttle.radio_in;
        g.channel_rudder.radio_out              = g.channel_rudder.radio_in;

        // setup extra aileron channel. We want this to come from the
        // main aileron input channel, but using the 2nd channels dead
        // zone, reverse and min/max settings. We need to use
        // pwm_to_angle_dz() to ensure we don't trim the value for the
        // deadzone of the main aileron channel, otherwise the 2nd
        // aileron won't quite follow the first one
        int16_t aileron_in = g.channel_roll.pwm_to_angle_dz(0);
        RC_Channel_aux::set_servo_out(RC_Channel_aux::k_aileron, aileron_in);

        // this aileron variant assumes you have the corresponding
        // input channel setup in your transmitter for manual control
        // of the 2nd aileron
        RC_Channel_aux::copy_radio_in_out(RC_Channel_aux::k_aileron_with_input);

        // copy flap control from transmitter
        RC_Channel_aux::copy_radio_in_out(RC_Channel_aux::k_flap_auto);

        if (g.mix_mode != 0) {
            // set any differential spoilers to follow the elevons in
            // manual mode. 
            RC_Channel_aux::set_radio(RC_Channel_aux::k_dspoiler1, g.channel_roll.radio_out);
            RC_Channel_aux::set_radio(RC_Channel_aux::k_dspoiler2, g.channel_pitch.radio_out);
        }
    } else {
        if (g.mix_mode == 0) {
            // both types of secondary aileron are slaved to the roll servo out
            RC_Channel_aux::set_servo_out(RC_Channel_aux::k_aileron, g.channel_roll.servo_out);
            RC_Channel_aux::set_servo_out(RC_Channel_aux::k_aileron_with_input, g.channel_roll.servo_out);
        }else{
            /*Elevon mode*/
            float ch1;
            float ch2;
            ch1 = g.channel_pitch.servo_out - (BOOL_TO_SIGN(g.reverse_elevons) * g.channel_roll.servo_out);
            ch2 = g.channel_pitch.servo_out + (BOOL_TO_SIGN(g.reverse_elevons) * g.channel_roll.servo_out);

			/* Differential Spoilers
               If differential spoilers are setup, then we translate
               rudder control into splitting of the two ailerons on
               the side of the aircraft where we want to induce
               additional drag.
             */
			if (RC_Channel_aux::function_assigned(RC_Channel_aux::k_dspoiler1) && RC_Channel_aux::function_assigned(RC_Channel_aux::k_dspoiler2)) {
				float ch3 = ch1;
				float ch4 = ch2;
				if ( BOOL_TO_SIGN(g.reverse_elevons) * g.channel_rudder.servo_out < 0) {
				    ch1 += abs(g.channel_rudder.servo_out);
				    ch3 -= abs(g.channel_rudder.servo_out);
				} else {
					ch2 += abs(g.channel_rudder.servo_out);
				    ch4 -= abs(g.channel_rudder.servo_out);
				}
				RC_Channel_aux::set_servo_out(RC_Channel_aux::k_dspoiler1, ch3);
				RC_Channel_aux::set_servo_out(RC_Channel_aux::k_dspoiler2, ch4);
			}

            // directly set the radio_out values for elevon mode
            g.channel_roll.radio_out  =     elevon1_trim + (BOOL_TO_SIGN(g.reverse_ch1_elevon) * (ch1 * 500.0/ SERVO_MAX));
            g.channel_pitch.radio_out =     elevon2_trim + (BOOL_TO_SIGN(g.reverse_ch2_elevon) * (ch2 * 500.0/ SERVO_MAX));
        }
}}}
=== ArduCopter Relevant Code ===
_motors_quad_
{{{
if(g.frame_orientation == X_FRAME){ 
		roll_out 	 	= (float)g.rc_1.pwm_out * 0.707;
		pitch_out 	 	= (float)g.rc_2.pwm_out * 0.707;

		// left
		motor_out[MOT_3]	= g.rc_3.radio_out + roll_out + pitch_out;	// FRONT
		motor_out[MOT_2]	= g.rc_3.radio_out + roll_out - pitch_out;	// BACK

		// right
		motor_out[MOT_1]	= g.rc_3.radio_out - roll_out + pitch_out;	// FRONT
		motor_out[MOT_4] 	= g.rc_3.radio_out - roll_out - pitch_out;	// BACK

	}
}}}
{{{...}}}
{{{
// Yaw input
	motor_out[MOT_1]	+=	g.rc_4.pwm_out; 	// CCW // FR Rotor
	motor_out[MOT_2]	+=	g.rc_4.pwm_out; 	// CCW  //BL Rotor
	motor_out[MOT_3]	-=	g.rc_4.pwm_out; 	// CW  //FL Rotor
	motor_out[MOT_4] 	-=	g.rc_4.pwm_out; 	// CW  //BR Rotor

    /* We need to clip motor output at out_max. When cipping a motors
		 * output we also need to compensate for the instability by
		 * lowering the opposite motor by the same proportion. This
		 * ensures that we retain control when one or more of the motors
		 * is at its maximum output
		 */
		for (int i = MOT_1; i <= MOT_4; i++){
				if(motor_out[i] > out_max){
		            // note that i^1 is the opposite motor
					motor_out[i ^ 1] -= motor_out[i] - out_max;
					motor_out[i] = out_max;
				}
		}

	// limit output so motors don't stop
	motor_out[MOT_1]	= max(motor_out[MOT_1], 	out_min);
	motor_out[MOT_2]	= max(motor_out[MOT_2], 	out_min);
	motor_out[MOT_3]	= max(motor_out[MOT_3], 	out_min);
	motor_out[MOT_4] 	= max(motor_out[MOT_4], 	out_min);
}}}
{{{...}}}
{{{
	APM_RC.OutputCh(MOT_1, motor_out[MOT_1]);
	APM_RC.OutputCh(MOT_2, motor_out[MOT_2]);
	APM_RC.OutputCh(MOT_3, motor_out[MOT_3]);
	APM_RC.OutputCh(MOT_4, motor_out[MOT_4]);
}}}


== Analysis ==
=== APM Analyzer ===
Current Version:  1.0
This software was created in MatLab and is used to analyze the Data Logs of the DIYDrones APM (2.0 or 2.5).  If you do not have MatLab all you need for this software is the MatLab RunTime Compiler, which is free. The original source code is also available in the download.

[http://code.google.com/p/icarus-uav-system/downloads/detail?name=APMAnalyzerv1.0.zip&can=2&q= APMAnalyzer Software] 

=== AirFoil Optimizer ===
Current Version: 1.0
This software was created in MatLab and is used to help select an airfoil given constraints.  It uses the airfoil data collected from [http://www.ae.illinois.edu/m-selig/ads/coord_database.html UIUC] and you can then filter and graph the airfoil data as you see fit. If you do not have MatLab all you need for this software is the MatLab RunTime Compiler, which is free. The original source code is also available in the download.

[http://code.google.com/p/icarus-uav-system/downloads/detail?name=AirfoilOptimizerv1.0.zip&can=2&q= Airfoil Optimizer]  


= References =
[http://code.google.com/p/ardupilot-mega/downloads/list ArduPlane Repo]

[http://code.google.com/p/arducopter/downloads/list ArduCopter Repo]