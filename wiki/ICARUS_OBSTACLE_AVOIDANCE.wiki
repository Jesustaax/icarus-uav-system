#summary One-sentence summary of this page.

[ICARUS_OBSTACLE_AVOIDANCE#Operation Operating Instructions]
[https://bitbucket.org/uicrobotics/icarus_oa ROS Source Code]
[https://www.dropbox.com/sh/5k0mwuku06bbsmt/agLkb_57Lh Propeller Source Code]

[PrimaryController Primary Controller]
[FlightController Flight Controller]
[MotionController Motion Controller]


= Milestones =
  * Design and Fabricate Sonic Sensor mounts (DONE)
  * Design and Fabricate Sonic Sensor Board for Daisy Chaining (DONE)
  * Install Sonic Sensors on UAV 
  * Calibrate Sensors to real Distances (INW)
  * Dev code for Force Mapping Algorithm (DONE)
  * Dev Code to acquire Sensor values. (DONE)
  * Test & Refine OA Code (Not Started)

== Summary ==
This project builds upon the previous project, [ICARUS_SLAM].  This project also uses the Quickstart and QuickstartPlus, along with Ultrasonic sensors and a Force Mapping algorithm to provide obstacle avoidance.  This can be used in cluttered environments, such as office spaces.

== Basic Operation ==

This project employs obstacle avoidance using Ultrasonic Sensors placed around the UAV.  These Sensors are placed at the Front, Left, Right, Back, Top and Bottom of the UAV.

The Ultrasonic Sensors have very little resolution, as they only report back the distance to the nearest obstacle they see.  But, since they have a fairly wide field of view and they consume little system resources (memory, space, weight, energy, etc) and they respond quickly to changes in their environment they are used to provide immediate feedback to the Force Mapping Algorithm used to adjust the motor speeds to avoid obstacles they perceive.

== Sensor Operation ==
The Sonar Sensors used in this Project are the [http://www.maxbotix.com/documents/MB1000_Datasheet.pdf Maxbotix LV-EZ0] Ultrasonic Sensors.  These sensors were selected due to their small size, variety of interfacing options, community support and precision.  Additionally the EZ0 sensors were selected due to their wide beamwidth necessary to find obstacles near the UAV.  In other applications sonar sensors with narrower beamwidths may be preferred, especially when performing mapping operations.

With these Sensors, it is necessary to daisy-chain them to avoid one sonar's transmit interfering with another sonar's reception.  As these sensors provide the necessary pinout and specifications to allow for daisy-chaining, [see http://www.maxbotix.com/documents/LV_Chaining_Constantly_Looping_AN_Out.pdf] all that is necessary is to build a board to facilitate this operation:

[http://dgitz.ipower.com/ICARUSRepo/Media/Flyer/Components/SonarBoard/SonarBoard.png]

To prevent spurious readings from the sonars interfering with the UAV's motion, each sensor is checked to make sure that the distance it reports is greater than 1" (the minimum range of the sensor) and averaged with the previous sensor reading.
 
== Force Mapping Algorithm ==

The Force Mapping Algorithm is fairly simple as the UAV requires high throughput and quick response times to mitigate risks it can cause to its environment, and risks the environment can cause the UAV.

Here is a breakdown of the tasks involved in the Force Mapping Algorithm:
 # The Flight Controller (FC) computes the PWM values for each Rotor Motor.
 # Instead of the FC normally sending these PWM values to each Rotor ESC directly, the Motion Controller (MC) reads this data instead.
 # The MC also reads the distance read for each of the Sonar Sensors.
 # Based on which Sonar reading is the lowest (i.e. closest) the MC applies an equation that offsets the appropriate motor PWM values.
 # The modified rotor PWM values are then applied to every rotor, providing obstacle avoidance on the UAV.

=== Mapping between the lowest Sonar reading and the Rotor PWM modifications ===

|| * _Lowest Sonar_ * || * _Required Action_ * || * _Front Rotor Change_ * || * _Left Rotor Change_ * || * _Back Rotor Change_ * || * _Right Rotor Change_ * ||
|| Top || Decrease Altitude || Decrease || Decrease || Decrease || Decrease ||
|| Bottom || Increase Altitude || Increase || Increase || Increase || Increase ||
|| Left || Roll Right || No Change || Increase || No Change || Decrease ||
|| Front || Pitch Back || Increase || No Change || Decrease || No Change ||
|| Right || Roll Left || No Change || Decrease || No Change || Increase ||
|| Back || Pitch Forwards || Decrease || No Change || Increase || No Change ||

A good algorithm will provide a large change in motion when an obstacle is near the UAV and a very small (or no) change when there are no obstacles near the UAV.  To generate the appropriate Force Mapping equation a Matlab script was created.  After some experimentation the equation
{{{
x: Distance (in)
max_us: Maximum Change of PWM Value, in micro-seconds, at x=0 inches
pwm_delta(x) = (33*max_us)/(x^2)
}}}

It will be required to determine the appropriate value of {{{ max_us }}} to provide good feedback for the UAV, as this will be hard (impossible?) to find analytically.  Currently, {{{max_us}}} is set to 1000 to provide the maximum change of motion, acknowledging that the PWM driver running on the MC limits the minimum/maximum PWM value to the the industry standard range of 1000 uS to 2000 uS.


[http://dgitz.ipower.com/ICARUSRepo/Media/Projects/ICARUS_OA/ForceMapping.png]

This figure is a graph of the previously defined equation, with x = 0:72 inches.

It is also noted that during the Pitch/Roll movements the desired change for each corresponding motor is exactly equal and opposite to each other.  Currently there is no support for changing the Yaw Angle of the UAV.

= Media =

[http://dgitz.ipower.com/ICARUSRepo/Media/Projects/ICARUS_OA/Flyer_Assy.png]
ICARUS Flyer

[http://dgitz.ipower.com/ICARUSRepo/Media/Projects/ICARUS_OA/Flyer_Assy_Detail.png]
ICARUS Flyer Detail

[http://dgitz.ipower.com/ICARUSRepo/Media/Projects/ICARUS_OA/Flyer_AssywUltrasonicBeams.png]

ICARUS Flyer w/ Ultrasonic Beams

[http://dgitz.ipower.com/ICARUSRepo/Media/Projects/ICARUS_OA/Flyer_AssywKinectFOV.png]

ICARUS Flyer w/ Kinect Field of View for Visible and IR Camera

[http://dgitz.ipower.com/ICARUSRepo/Media/Projects/ICARUS_OA/Flyer_AssywEverything.png]

ICARUS Flyer w/ Kinect Field of View and Ultrasonic Beams

[https://www.dropbox.com/s/3723pg8ld2cp65k/ProgramFlowchart.pptx Software Flowchart]

[https://www.dropbox.com/s/qtkywga5dyuwr1r/Software%20Documentation.docx Software Documentation]

= Installation/Development Instructions =

== Compiling ==
{{{

}}}


== Commit ==
 # Add any uncommitted files:
{{{
git add .
}}}
 # Make a comment on the commit and then push it to the main branch.
{{{
git commit -m "Comment Text"
git push -u origin master
}}}

= Operation =
== Headless ==
 * In Terminal 1:
{{{
roscore
}}}

 * In Terminal 2:
{{{
roslaunch oa slow_computer2.launch
}}}
 
 * In Terminal 3:
{{{
sudo chmod 0777 /dev/ttyACM0
}}}

Execute the main program with the following:
{{{
roscd icarus_oa
python oa/nodes/primarycontroller.py
}}}
The following options are available.  Use the text in the <> where applicable, | signifies different options, and omit the <> and |:
 * Connection to GCS (Transmit GPS and Attitude Completed)
{{{
--gcs-device-type=<udp|Serial>
--gcs-device=<Device> #Where Device is an IP address if the type is udp, or a Serial Device such as /dev/ttyUSB0 or /dev/ttyACM0
--gcs-device-speed=<Speed> #Where Speed is a compatible baud rate if the type is Serial (default is 115200) and if not used the type is udp 
}}}
 * Connection to Flight Controller (Receive Attitude Completed)
{{{
--fc-device-type=<udp|Serial>
--fc-device=<Device> #Where Device is an IP address if the type is udp, or a Serial Device such as /dev/ttyUSB0 or /dev/ttyACM0
--fc-device-speed=<Speed> #Where Speed is a compatible baud rate if the type is Serial (default is 115200) and not used the type is udp 
}}}
 * Connection to Flight Controller GPS
{{{
--fcgps-device-type=<udp|Serial>
--fcgps-device=<Device> #Where Device is an IP address if the type is udp, or a Serial Device such as /dev/ttyUSB0 or /dev/ttyACM0
--fcgps-device-speed=<Speed> #Where Speed is a compatible baud rate if the type is Serial (default is 115200) and not used the type is udp 
}}}
 * Connection to Motion Controller
{{{
--mc-device-type=<Serial>
--mc-device=<Device> #Where Device is a Serial Device such as /dev/ttyUSB0 or /dev/ttyACM0
--mc-device-speed=<Speed> #Where Speed is a compatible baud rate
}}}
 * Connection to Remote (Transmit GPS and Attitude In Progress)
{{{
--remote-device-type=<udp|Serial>
--remote-device=<Device> #Where Device is an IP address if the type is udp, or a Serial Device such as /dev/ttyUSB0 or /dev/ttyACM0
--remote-device-speed=<Speed> #Where Speed is a compatible baud rate if the type is Serial (default is 115200) and not used the type is udp 
}}}

 * Example
{{{
oa/nodes/primarycontroller.py --fcgps-device-type=Serial --fcgps-device=/dev/ttyUSB0 --fc-device-type=Serial --fc-device=/dev/ttyACM0 --gcs-device-type=udp --gcs-device=10.7.45.208
}}}

= References =